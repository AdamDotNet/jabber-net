#summary How do I add my own packet types?

(thanks to Tom Waters for this)

Say you want to use a new packet type like this:
{{{
<!-- get your own list of all your objects... -->
<iq type='get' to='self' id='n0'>
 <query xmlns='your:namespace'/>
</iq>

<!-- reply with list of objects... -->
<iq type='result' to='self' id='n0'>
 <query xmlns='your:namespace'>
  <yourobj key='Object1' other='value1'/>
 </query>
</iq>
}}}

In order to get the inbound connection to create objects of your class, rather than just plain XmlElements, you need to create a Factory class, and register it with your connection object in the OnStreamInit event.

{{{
private void jabberClient_OnStreamInit(object sender, ElementStream stream)
{
    stream.AddFactory(new your.protocol.Factory());
}
}}}

For an example of a factory class, see jabber.protocol.iq.Factory.

Next, make sure you implement both of these constructors for your type:

{{{
namespace your.protocol
{
   public class YourQuery : Element 
   {
      public const string YOUR_NS  = "your:namespace";

      public YourQuery(XmlDocument doc) : base("query", YOUR_NS, doc) 
      {}

      // this constructor is used by the Factory!
      public YourQuery(string prefix, XmlQualifiedName qname, XmlDocument doc) : 
          base(prefix, qname, doc) 
      {}
   }


    public class Factory : jabber.protocol.IPacketTypes 
   {
      private static QnameType[] s_qnt = new QnameType[] 
      {
         new QnameType("query", YourQuery.YOUR_NS, typeof(YourQuery))
         // Add other types here, perhaps sub-elements of query...
      };
      QnameType[] IPacketTypes.Types { get { return s_qnt; } }
   }
}
}}}

One more note.  Most of the classes you are liable to write should derive from jabber.protocol.Element.  jabber.protocol.Packet is for top-level jabber packets, like <message/>, <iq/>, and <presence/>.
